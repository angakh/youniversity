# youtube_utils.py

import os
import logging
import re
from typing import Dict, List, Optional, Tuple, Any
from youtube_transcript_api import YouTubeTranscriptApi, TranscriptsDisabled, NoTranscriptFound
import whisper
from pytube import YouTube
import torch
import time
from pathlib import Path
import tempfile

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class YouTubeTranscriptFetcher:
    """Fetches transcripts from YouTube videos"""
    
    def __init__(self, model_size: str = "base"):
        """
        Initialize the transcript fetcher.
        
        Args:
            model_size: Size of the whisper model (tiny, base, small, medium, large)
        """
        self.model_size = model_size
        self.whisper_model = None  # Lazy load to save memory
    
    def get_video_id(self, url: str) -> str:
        """
        Extract the video ID from a YouTube URL.
        
        Args:
            url: YouTube URL
            
        Returns:
            YouTube video ID
        """
        # Handle different URL formats
        if "youtu.be" in url:
            video_id = url.split("youtu.be/")[-1].split("?")[0]
        elif "youtube.com/watch" in url:
            video_id = re.search(r"v=([^&]+)", url).group(1)
        elif "youtube.com/embed/" in url:
            video_id = url.split("youtube.com/embed/")[-1].split("?")[0]
        else:
            raise ValueError(f"Unsupported YouTube URL format: {url}")
        
        return video_id
    
    def get_transcript(self, url: str) -> Tuple[List[Dict[str, Any]], Dict[str, Any]]:
        """
        Get the transcript for a YouTube video.
        
        Args:
            url: YouTube URL
            
        Returns:
            Tuple of (transcript segments, video info)
        """
        video_id = self.get_video_id(url)
        logger.info(f"Fetching transcript for video ID: {video_id}")
        
        # Get video info
        video_info = self.get_video_info(video_id)
        
        # Try to get transcript from YouTube API
        try:
            transcript_list = YouTubeTranscriptApi.list_transcripts(video_id)
            
            # Try to get English transcript first, then any available
            try:
                transcript = transcript_list.find_transcript(['en'])
            except NoTranscriptFound:
                transcript = transcript_list.find_generated_transcript()
            
            # Get the transcript data
            transcript_data = transcript.fetch()
            logger.info(f"Successfully fetched transcript with {len(transcript_data)} segments")
            
            return transcript_data, video_info
            
        except (TranscriptsDisabled, NoTranscriptFound) as e:
            logger.warning(f"No transcript available via API: {str(e)}")
            logger.info("Attempting to generate transcript from audio...")
            
            return self.generate_transcript_from_audio(url, video_info)
            
        except Exception as e:
            logger.error(f"Error fetching transcript: {str(e)}")
            raise
    
    def get_video_info(self, video_id: str) -> Dict[str, Any]:
        """
        Get video information using pytube.
        
        Args:
            video_id: YouTube video ID
            
        Returns:
            Dictionary of video information
        """
        try:
            url = f"https://www.youtube.com/watch?v={video_id}"
            yt = YouTube(url)
            
            video_info = {
                "title": yt.title,
                "author": yt.author,
                "length": yt.length,
                "thumbnail_url": yt.thumbnail_url,
                "video_id": video_id
            }
            
            logger.info(f"Successfully fetched video info: {yt.title}")
            return video_info
            
        except Exception as e:
            logger.error(f"Error getting video info: {str(e)}")
            
            # Return minimal info on error
            return {
                "title": "Video title unavailable",
                "author": "Author unavailable",
                "length": 0,
                "thumbnail_url": f"https://img.youtube.com/vi/{video_id}/hqdefault.jpg",
                "video_id": video_id
            }
    
    def load_whisper_model(self):
        """Load the Whisper model if not already loaded."""
        if self.whisper_model is None:
            logger.info(f"Loading Whisper model (size: {self.model_size})...")
            self.whisper_model = whisper.load_model(self.model_size)
            logger.info("Whisper model loaded")
    
    def generate_transcript_from_audio(self, url: str, video_info: Dict[str, Any]) -> Tuple[List[Dict[str, Any]], Dict[str, Any]]:
        """
        Generate a transcript from the audio track of a video.
        
        Args:
            url: YouTube URL
            video_info: Video information dictionary
            
        Returns:
            Tuple of (transcript segments, video info)
        """
        try:
            # Lazy load the Whisper model
            self.load_whisper_model()
            
            # Download audio
            yt = YouTube(url)
            audio_stream = yt.streams.filter(only_audio=True).first()
            
            # Use a temporary directory for the download
            with tempfile.TemporaryDirectory() as temp_dir:
                temp_path = Path(temp_dir)
                audio_file = temp_path / "audio.mp4"
                
                logger.info(f"Downloading audio from: {url}")
                audio_stream.download(output_path=str(temp_path), filename="audio.mp4")
                
                # Transcribe the audio
                logger.info("Transcribing audio...")
                result = self.whisper_model.transcribe(str(audio_file))
                
                # Convert Whisper result to YouTube transcript format
                transcript_data = []
                
                for segment in result["segments"]:
                    transcript_data.append({
                        "text": segment["text"].strip(),
                        "start": segment["start"],
                        "duration": segment["end"] - segment["start"]
                    })
                
                logger.info(f"Generated transcript with {len(transcript_data)} segments")
                return transcript_data, video_info
                
        except Exception as e:
            logger.error(f"Error generating transcript from audio: {str(e)}")
            raise
    
    def format_transcript_for_context(self, transcript: List[Dict[str, Any]], 
                                    video_info: Dict[str, Any], 
                                    url: str) -> str:
        """
        Format the transcript for use as context in LLM prompts.
        
        Args:
            transcript: List of transcript segments
            video_info: Video information dictionary
            url: YouTube URL
            
        Returns:
            Formatted transcript text
        """
        if not transcript:
            return "No transcript available."
        
        title = video_info.get("title", "Unknown Title")
        author = video_info.get("author", "Unknown Author")
        
        # Format header
        formatted_text = f"TITLE: {title}\n"
        formatted_text += f"CREATOR: {author}\n"
        formatted_text += f"URL: {url}\n\n"
        formatted_text += "TRANSCRIPT:\n"
        
        # Format each segment with timestamp
        for segment in transcript:
            time_str = self.format_time(segment["start"])
            timestamped_url = self.get_timestamped_url(url, segment["start"])
            formatted_text += f"[{time_str}] {segment['text']}\n"
        
        return formatted_text
    
    def format_time(self, seconds: float) -> str:
        """
        Format a timestamp in seconds to MM:SS format.
        
        Args:
            seconds: Time in seconds
            
        Returns:
            Formatted time string (MM:SS)
        """
        minutes = int(seconds // 60)
        seconds = int(seconds % 60)
        return f"{minutes:02d}:{seconds:02d}"
    
    def get_timestamped_url(self, url: str, seconds: float) -> str:
        """
        Generate a timestamped YouTube URL.
        
        Args:
            url: Base YouTube URL
            seconds: Time in seconds
            
        Returns:
            Timestamped YouTube URL
        """
        # Remove any existing timestamp
        if "?" in url:
            base_url = url.split("?")[0]
            query_params = url.split("?")[1]
            params = dict(param.split("=") for param in query_params.split("&") if "=" in param)
            
            # Remove any existing timestamp parameter
            if "t" in params:
                del params["t"]
            
            # Rebuild the URL without the timestamp
            if params:
                base_url += "?" + "&".join([f"{key}={value}" for key, value in params.items()])
            
            url = base_url
        
        # Add the timestamp parameter
        if "?" in url:
            time_param = f"&t={int(seconds)}s"
        else:
            time_param = f"?t={int(seconds)}s"
        
        return url + time_param